# 双向链表(Deque [double queue], pronounce: Deck)
## 双向链表的介绍
使用带有head头的双向链表实现数据排行榜管理单向链表缺点分析：
* 单向链表，查找的方向只能为一个方向， 而双向链表可以向前或者向后查找。
* 单向链表不能够自我删除， 需要靠辅助节点， 而双向链表则可以实现自我删除，
所以前面我们单向链表删除节点时， 总是找到temp（带删除节点）的前一个节点
来删除。

## 约瑟夫（Josephu）问题（环形单向链表）
Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的
人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又
出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。

> 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，
然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点
的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

构建一个单向环形链表思路
1. 先构建第一个节点， 让first指向该节点， 并形成一个环形
2. 当我们每创建一个新当节点， 就把该节点， 加入到已有到环形链表中即可

遍历环形链表
1. 先让一个辅助变量curr， 指向first节点
2. 然后通过一个while循环遍历该环形链表即可, curr.next == first （遍历完毕）

实例： 根据用户输入， 生成一个小孩的出圈顺序： n=5, 即共五个小孩； k=1, 从第一个人
开始报数；m=2，数2下。

逻辑：
1. 需求创建一个辅助指针变量helper， 事先应该指向环形链表的最后这个节点。
补充： 小孩报数时， 先让first和helper移动k-1次。
2. 当小孩报数时， 让first和helper指针同时移动m-1次。
3. 这时就可以将first指向的小孩节点出圈,原来first的节点没有引用则会被回收。
```javascript
first = first.next;
helper.next = first;
```
 